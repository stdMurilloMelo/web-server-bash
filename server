#!/usr/bin/env bash

VERSION='v1.0.0'

PORT=8080
ADDRESS='127.0.0.1'
DIR='.'

read -d '' -r USAGE <<-EOF
Usage: [-p port] [-b addr] [-d dir]

HTTP server in Bash.

Options
  -b <addr>  Address to bind to, defaults to localhost.
  -d <dir>   Directory to serve, defaults to your current directory.
  -h         Print this message and exit.
  -p <port>  Port to bind to, defaults to 8080.
  -v         Print the version number and exit.
EOF

fatal() {
    echo '[fatal]' "$@" >&2
    exit 1
}

mime-type() {
    local f=$1
    local bname=${f##*/}
    local ext=${bname##*.}
    [[ $bname == "$ext" ]] && ext=

    case "$ext" in
    html | htm) echo 'text/html' ;;
    jpeg | jpg) echo 'image/jpeg' ;;
    png) echo 'image/png' ;;
    txt) echo 'text/plain' ;;
    css) echo 'text/css' ;;
    js) echo 'text/javascript' ;;
    json) echo 'application/json' ;;
    *) echo 'application/octet-stream' ;;
    esac
}

html-encode() {
    local s=$1

    s=${s//&/\&amp;}
    s=${s//</\&lt;}
    s=${s//>/\&gt;}
    s=${s//\"/\&quot;}
    s=${s//\'/\&apos;}

    echo "$s"
}

list-directory() {
    local d=$1

    shopt -s nullglob dotglob

    echo '<!DOCTYPE html>'
    echo '<html lang="en">'
    echo '<head>'
    echo '  <meta charset="utf-8">'
    printf '  <title>Index of %s</title>\n' "$(html-encode "$d")"
    echo '  <style>'
    echo '  body {'
    echo '    background-color: Canvas;'
    echo '    color: CanvasText;'
    echo '    color-scheme: light dark;'
    echo '  }'
    echo '  a, a:visited, a:active {'
    echo '    text-decoration: none;'
    echo '  }'
    echo '  </style>'
    echo '</head>'
    echo '<body>'
    echo '<h1>Directory Listing</h1>'
    echo "<h2>Directory: $(html-encode "$d")</h2>"
    echo '<hr>'
    echo '<ul>'
    local f
    # loop directories first (to put at top of list)
    for f in .. "$d"/*/; do
        local bname=${f%/}
        bname=${bname##*/}

        local display_name="üìÅ $bname/"
        printf '<li><a href="%s">%s</a></li>\n' \
            "$(urlencode "$bname")" \
            "$(html-encode "$display_name")"
    done
    # loop regular files next (non-directories)
    for f in "$d"/*; do
        [[ -f $f ]] || continue
        local bname=${f##*/}

        local display_name="üìÑ $bname"
        printf '<li><a href="%s">%s</a></li>\n' \
            "$(urlencode "$bname")" \
            "$(html-encode "$display_name")"
    done
    echo '</ul>'
    echo '<hr>'
    echo '</body>'
    echo '</html>'
}

urlencode() {
    # Usage: urlencode "string"
    local LC_ALL=C
    for ((i = 0; i < ${#1}; i++)); do
        : "${1:i:1}"
        case "$_" in
        [a-zA-Z0-9.~_-])
            printf '%s' "$_"
            ;;

        *)
            printf '%%%02X' "'$_"
            ;;
        esac
    done
    printf '\n'
}

urldecode() {
    # Usage: urldecode "string"
    : "${1//+/ }"
    printf '%b\n' "${_//%/\\x}"
}

normalize-path() {
    local path=/$1

    local parts
    IFS='/' read -r -a parts <<<"$path"

    local -a out=()
    local part
    for part in "${parts[@]}"; do
        case "$part" in
        '') ;;  # ignore empty directories (multiple /)
        '.') ;; # ignore current directory
        '..') unset 'out[-1]' 2>/dev/null ;;
        *) out+=("$part") ;;
        esac
    done

    local s
    s=$(
        IFS=/
        echo "${out[*]}"
    )
    echo "/$s"
}

parse-request() {
    declare -gA REQ_INFO=()
    declare -gA REQ_HEADERS=()

    local state='status'
    local line
    while read -r line; do
        line=${line%$'\r'}

        case "$state" in
        'status')
            # parse the status line
            # "GET /foo.txt HTTP/1.1"
            local method path version
            read -r method path version <<<"$line"
            REQ_INFO[method]=$method
            REQ_INFO[path]=$path
            REQ_INFO[version]=$version
            state='headers'
            ;;
        'headers')
            # parse the headers
            if [[ -z $line ]]; then
                # XXX no support to body parsing
                break
            fi
            local key value
            IFS=: read -r key value <<<"$line"
            key=${key,,}
            value=${value# *}
            REQ_HEADERS[$key]=$value
            ;;
        'body')
            fatal 'body parsing not supported'
            ;;
        esac
    done
}

process-request() {
    # no fd parameter needed
    parse-request <&0 # read from stdin

    # validate the request
    [[ ${REQ_INFO[version]} == 'HTTP/1.1' ]] || fatal "unsupported HTTP version"
    [[ ${REQ_INFO[method]} == 'GET' ]] || fatal 'unsupported HTTP method'
    [[ ${REQ_INFO[path]} == /* ]] || fatal 'path must be absolute'

    echo "${REQ_INFO[method]} ${REQ_INFO[path]}" >&2

    local path="${REQ_INFO[path]}"
    path=${path:1}
    local query
    IFS='?' read -r path query <<<"$path"
    path=$(urldecode "$path")
    path=$(normalize-path "$path")
    path=${path:1}
    path=${path:-.}

    local totry=(
        "$path"
        "$path/index.html"
        "$path/index.htm"
    )
    local try file
    for try in "${totry[@]}"; do
        [[ -f $try ]] && {
            file=$try
            break
        }
    done

    if [[ -n $file ]]; then
        local mime
        mime=$(mime-type "$file")
        printf 'HTTP/1.1 200 OK\r\n'
        printf 'Content-Type: %s\r\n' "$mime"
        printf '\r\n'
        cat "$file"
    elif [[ -d $path ]]; then
        if [[ ${REQ_INFO[path]} != */ ]]; then
            printf 'HTTP/1.1 301 Moved Permanently\r\n'
            printf 'Location: %s/\r\n' "${REQ_INFO[path]}"
            printf '\r\n'
            return
        fi
        printf 'HTTP/1.1 200 OK\r\n'
        printf 'Content-Type: text/html; charset=utf-8\r\n'
        printf '\r\n'
        list-directory "$path"
    else
        printf 'HTTP/1.1 404 Not Found\r\n'
        printf '\r\n'
    fi
}

main() {
    if [[ "$1" == "_handle_request" ]]; then
        process-request
        exit 0
    fi

    local OPTIND OPTARG opt
    while getopts 'b:hp:d:v' opt; do
        case "$opt" in
        b) ADDRESS=$OPTARG ;;
        p) PORT=$OPTARG ;;
        d) DIR=$OPTARG ;;
        h)
            echo "$USAGE"
            exit 0
            ;;
        v)
            echo "$VERSION"
            exit 0
            ;;
        *)
            echo "$USAGE" >&2
            exit 2
            ;;
        esac
    done

    cd "$DIR" || fatal "failed to move to $DIR"

    command -v ncat >/dev/null 2>&1 || fatal 'ncat not found, please install nmap package'

    echo "listening on http://$ADDRESS:$PORT"
    echo "serving out of $PWD"

    ncat -k -l "$ADDRESS" "$PORT" --sh-exec "$0 _handle_request"
}

main "$@"
